<!DOCTYPE html>
<html>
	<head>
		<title>MY BLOG</title>
		<meta charset="utf-8" />
		<link rel="shortcut icon" href="../favicon.ico" /> 
		<link rel="stylesheet" type="text/css" href="../styles/main.css" />
		<link rel="stylesheet" type="text/css" href="../styles/demo.css" />
	</head>
	<body>
		<div class="wrapper">
			<div class="container">
				<div class="primary">
					<div class="header">
						<h1><a href="index.html"><span>ZHRJ</span>博客</a></h1>
						<p>······前端的路很长很长······</p>
						<ul class="nav">
							<li><a href="../index.html">首页</a></li>
							<li><a href="../demo.html">demo</a></li>
							<li><a href="../rebuild.html">网页重构</a></li>
							<li><a href="../aboutjs.html">javascript</a></li>
							<li><a href="../aboutme.html">关于我</a></li>
						</ul>
					</div>
					<div class="sider">
						<div class="sider-box blog-box">
							<h4>关注的博客</h4>
							<ul>
								<li><a href="http://www.zhangxinxu.com/wordpress/">张鑫旭博客</a></li>
								<li><a href="http://www.cssforest.org/blog/">CSS森林</a></li>
								<li><a href="http://coolshell.cn/">酷壳</a></li>
								<li><a href="http://www.qianduan.net/">前端观察</a></li>
							</ul>
						</div>
						<div class="sider-box paper-box">
							<h4>收藏的文章</h4>
							<ul>
								<li><a href="https://github.com/lifesinger/lifesinger.github.com/issues/105">最牛逼的 HTML 和 CSS 代码的背后</a></li>
								<li><a href="http://www.zhangxinxu.com/wordpress/2012/07/bottleneck-css-study/">说说CSS学习中的瓶颈</a></li>
							</ul>
						</div>
						<div class="sider-box me-box">
							<h4>联系我</h4>
							<ul>
								<li>博客园：<a href="http://www.cnblogs.com/zhrj000/">http://www.cnblogs.com/zhrj000/</a></li>
								<li>新浪微博：<a href="http://weibo.com/inthecorner">http://weibo.com/inthecorner</a></li>
								<li>网易邮箱：<a href="http://www.cnblogs.com/zhrj000/">zhrj000@163.com</a></li>
							</ul>
						</div>
					</div>
				</div>
				<div class="content">
					<div class="article">
						<h2>js原型与继承</h2>
						<p class="posttime">——发表于2012/10/20 </p>
						<p>1）关于原型</p>
						<p>创建的新函数有一个prototype指针，指向一个原型对象。原型对象有一个construct属性，指回去函数，形成一个环。函数创建一个新实例后，实例会有一个内部属性__proto__ ，指向原型对象。</p>
						<p>2）关于重写原型对象</p>
						<p>一般我们给原型对象添加属性和方法的时候，都会这样添加：</p>
<pre>
Person.prototype.name="zakas";
    Person.prototype.sayName=function(){
    console.log(this.name);  
}</pre>
						<p>如果用对象字面量的话：</p>
<pre>
Person.prototype={
    name:"zakas"，
    sayName:function(){
    console.log(this.name);
    }
}</pre>
						<p>就会重写了整个原型对象，即constructor属性不再指向Person了。如果这个constructor的值真的重要的话，可以手动加入代码：</p>
<pre>
Person.prototype={
    constructor:Person,
    name:"zakas"，
    sayName:function(){
        console.log(this.name);
    }
}</pre>
						<p>3）关于继承——原型链继承</p>
<pre>SubType.prototype=new SuperType();</pre>
						<p>子函数要继承父函数的时候，将子函数的prototype指针指向一个父函数的实例，，父函数实例就会有一个__proto__属性，指向父函数的原型对象。</p>
						<p>用子函数创建一个实例后，子函数实例的内部__proto__指向子函数的原型对象，子函数的原型对象（即父函数的实例）的内部__proto__指向父函数的原型对象。</p>
						<p>原型链的缺点就是：</p>
						<p>1、父函数里面的属性，在实例后，就变成了子函数的prototype对象的属性，如果这个属性是个引用类型的话（如数组），那么所有的子函数的实例将共享这 个属性（因为如果是基本类型的话，属性的赋值就会是在实例中添加新的属性，原型对象中的属性是不变的，但是如果是引用类型的话，如数组，往数组里面push数据是真的往原型对象的属性push数据）；</p>
						<p>2、子函数无法向父函数的构造函数传递参数</p>
						<p>4）关于继承——借用构造函数 </p>
<pre>
var SubType=function(){
    SuperType.call(this);
}</pre>
						<p>借用构造函数的缺点就是：</p>
						<p>1、只是借用了父函数的构造函数，并没用借用到父函数的原型对象，就没有了所谓的函数复用</p>
						<p>5）关于继承——寄生组合式</p>
<pre>
var object=function(o){
    var F=function(){};
    F.prototype=o;
    return new F();
 };
 var inheritPrototype=function(subType,superType){
    var prototype=object(superType.prototype);
    prototype.constructor=subType;
    subType.prototype=prototype;
 };
 
 var SuperType=function(name){
    this.name=name;
 };
 SuperType.prototype.sayName=function(){
    alert(this.name);
 };
 var SubType=function(name,age){
    SuperType.call(this,name);
    this.age=age;
 };
 inheritPrototype(SubType,SuperType);</pre>
						<p>寄生组合式的原理是：</p>
						<p>1、第19行代码，用call解决了原型链的两个缺点。call只是借用了构造函数，然后其他就是下面一点了</p>
						<p>2、object函数的作用，说得通俗一点，就是将SuperType的构造函数抽空，然后返回一个实例（为什么抽空构造函数呢，因为SuperType的构造函数已经用call解决了），然后inheritPrototype函数将SubType的原型对象设置为该实例</p>
						<p>所以，寄生组合式真正实现了继承吧。。。。</p>
						<p>5)关于instanceof</p>
						<p>我们通常会用instanceof来判断一个变量是不是某个对象的实例</p>
						<p>如obj instanceof class</p>
						<p>那么内在是如何运作的，其实instanceof判断的而是obj原型链上的原型是否与class的原型是同一个对象，是返回true，不是返回false</p>
						<p>所以说，用instanceof来判断一个变量是否是某个对象的实例是不精准的，任何一个函数，只要改写他的prototype，它都可能“成为某个实例的对象”</p>
					</div>
				</div>
			</div>
			<div class="footer">Copyright © 2012 <a href="http://zhrj000.github.com/">zhrj000.github.com</a> All rights reserved.</div>
		</div>
	</body>
</html>